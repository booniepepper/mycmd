#!/usr/bin/env /bin/sh
# -*- mode: shell-script; sh-shell: sh; sh-basic-offset: 4; sh-indentation: 4; coding: utf-8 -*-
# shellcheck shell=sh

# ------------------------------------------------------------------------------
# MyCmd Shell Bash Loader
#  Ugly hack because I have some circumstances where I can't put a new enough
#  Bash interpreter for the features used in MyCmd on the PATH, but I want the
#  MyCmd commands to be portable across systems.
#
# To use this, this script itself must be on the PATH. Then, the following
# shebang line is used:
#
# #!/usr/bin/env bash-loader
#
# It is written as minimally as possible, so any `/bin/sh` should be sufficient
# to execute it.

bash_path=''

# If the user has MYCMD_BASH_PATH set, use that if valid
if [ -n "${MYCMD_BASH_PATH}" ] && [ -e "${MYCMD_BASH_PATH}" ]; then
    bash_path="${MYCMD_BASH_PATH}"
fi

# Next Check for any Bash interpreters on the PATH
if [ -z "${bash_path}" ]; then
    for potential in $(which -a bash); do
        # Need version 4.4 or newer for associative array support (among others).
        "${potential}" --noprofile --norc <<'EOF'
(("${BASH_VERSINFO[0]}" > 4)) && exit 0

if [[ "${BASH_VERSINFO[0]}" -eq 4 ]]; then
    if [[ "${BASH_VERSINFO[1]}" -ge 4 ]]; then
        exit 0
    fi
fi

exit 1
EOF
        if [ $? -eq 0 ]; then
            bash_path="${potential}"
            break
        fi
    done
fi

if [ -z "${bash_path}" ]; then
    echo "Unable to find suitable Bash interpreter, not executing ${*}" 1>&2
    exit 1
fi

exec "${bash_path}" "${*}"
